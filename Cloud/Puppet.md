# Puppet
Puppet (маріонетка) – це популярний інструмент для управління конфігурацією, який дозволяє автоматизувати налаштування серверів, управління програмним забезпеченням та їх конфігурацію. Puppet використовує декларативний підхід, що дозволяє визначити бажаний стан системи, після чого самостійно застосовує необхідні зміни для досягнення цього стану.

## Основні компоненти Puppet:
- `Master` (керівник): Центральний сервер, який контролює управління конфігурацією. Він зберігає всі конфігурації, правила і модули.

- `Agent` (агент): Інстальований на кожному сервері, який управляється Puppet. Агент регулярно звертається до мастера для отримання інструкцій та застосування конфігурацій.

- `Manifests` (маніфести): Це файли, які описують конфігурації ресурсів у форматі, зрозумілому Puppet. Маніфести визначають, як повинні виглядати різні компоненти системи.

- `Modules` (модулі): Пакети, що містять маніфести, файли ресурсів та інші файли, які можуть бути повторно використані в різних проектах. Модулі дозволяють організувати та структурувати конфігурації.

- `Resources` (ресурси): Це окремі елементи управління, такі як пакети, служби, файли тощо, які Puppet може контролювати. Кожен ресурс має власні атрибути, які визначають його стан.

## Переваги використання Puppet:
- `Автоматизація`: Зменшує ручну роботу з налаштуванням серверів і управлінням конфігураціями.
- `Консистентність`: Забезпечує однаковість конфігурацій на різних серверах, зменшуючи ризик помилок.
- `Масштабованість`: Легко управляти великими кластерами серверів.
- `Аудит і звітність`: Можливість контролювати зміни та стежити за станом системи.

## Ляльковий ресурс
Ляльковий ресурс (Puppet resource) – це базовий елемент, який Puppet контролює. Це може бути будь-який компонент системи, з яким потрібно працювати, наприклад:

- `Пакет`: Установлений пакет програмного забезпечення.
- `Файл`: Конфігураційний файл або будь-який інший файл у файловій системі.
- `Служба`: Служба, яка повинна бути запущена або зупинена.

Кожен ресурс має свої атрибути, які визначають, в якому стані він повинен бути (наприклад, файл повинен бути певного типу, пакет має бути встановлений, а служба – запущена).

 
## Приклад налаштування Puppet для управління конфігурацією сервера. 
У цьому прикладі ми створимо простий модуль Puppet, який встановлює веб-сервер Apache на Ubuntu, налаштовує його, а також забезпечує, щоб він запускався автоматично при завантаженні системи.

### Кроки налаштування
1. Встановлення Puppet

   Перш ніж почати, переконайтеся, що Puppet встановлений на вашій машині. Ви можете це зробити, виконавши такі команди:

```bash
sudo apt update
sudo apt install puppet
```

2. Створення модуля Puppet

   Для створення модуля, відкрийте термінал і виконайте такі команди:

```bash
sudo puppet module generate myorg-apache
```
Це створить базову структуру модуля.

3. Редагування файлів модуля

    Перейдіть до каталогу, створеного для модуля:

```bash
cd /etc/puppet/modules/myorg-apache
```

   Відкрийте файл init.pp у каталозі manifests для редагування:

```bash
sudo nano manifests/init.pp
```

4. Додавання конфігурації для установки Apache

   Вставте наступний код у файл init.pp:

```puppet
class myorg::apache {
    # Встановлення пакету Apache
    package { 'apache2':
        ensure => installed,
    }

    # Запуск служби Apache
    service { 'apache2':
        ensure => running,
        enable => true,
        subscribe => Package['apache2'],  # Перезапустити службу при установці пакету
    }

    # Копіювання файлу конфігурації
    file { '/etc/apache2/sites-available/000-default.conf':
        ensure  => file,
        source  => 'puppet:///modules/myorg-apache/000-default.conf',
        notify  => Service['apache2'],  # Перезапустити службу при зміні файлу
    }
}
```

   Опис властивостей
   - `class myorg::apache:`  Це оголошення класу. Класи в Puppet дозволяють групувати ресурси, щоб їх можна було використовувати разом. У цьому випадку ми створюємо клас myorg::apache, який містить усі ресурси, пов'язані з Apache.
   - `package { 'apache2': ... }:`
      - `package`: Цей ресурс управляє пакетами. В даному випадку ми використовуємо його для установки пакету Apache.
      - `'apache2'`: Ім'я пакету, який ми хочемо встановити.
   - `ensure => installed`: Ця властивість визначає бажаний стан пакету. В даному випадку installed означає, що пакет повинен бути встановлений. Інші значення можуть включати absent (для видалення пакету) або latest (для установки останньої версії).
   - `service { 'apache2': ... }:`
      - `service`: Цей ресурс управляє службами (демонами) на сервері.
      - `'apache2'`: Ім'я служби, яку ми хочемо контролювати.
   - `ensure => running`: Ця властивість вказує, що служба повинна бути запущена. Можливі значення: running, stopped або true/false.
   - `enable => true`: Ця властивість визначає, чи служба повинна автоматично запускатися при завантаженні системи. Якщо встановлено true, служба буде включена в список автоматичного запуску.
   - `subscribe => Package['apache2']`: Ця властивість вказує, що служба повинна перезапускатися, якщо ресурс пакету apache2 змінюється (наприклад, якщо пакет буде перевстановлено або оновлено).
   - `file { '/etc/apache2/sites-available/000-default.conf': ... }:`
      - `file`: Цей ресурс управляє файлами і каталогами на файловій системі.
      - `'/etc/apache2/sites-available/000-default.conf'`: Шлях до файлу, який ми хочемо управляти.
   - `ensure => file`: Ця властивість вказує, що ресурс повинен бути файлом. Інші можливі значення: directory (для каталогів) або absent (для видалення файлу/каталогу).
   - `source => 'puppet:///modules/myorg-apache/000-default.conf'`: Ця властивість визначає джерело файлу, яке буде скопійовано в зазначене місце. puppet:/// є URI, який вказує на те, що файл знаходиться в модулях Puppet.
   - `notify => Service['apache2']`: Ця властивість вказує, що служба apache2 повинна бути перезапущена, якщо файл конфігурації змінюється.

5. Створення конфігураційного файлу Apache

   Тепер створіть файл конфігурації Apache, який ви вказали в коді вище. Для цього виконайте наступні команди:

```bash
sudo nano files/000-default.conf
```
   Додайте наступну конфігурацію до файлу:


```apache
<VirtualHost *:80>
    DocumentRoot /var/www/html
    <Directory /var/www/html>
        AllowOverride All
    </Directory>
</VirtualHost>
```
6. Застосування конфігурації Puppet

   Після того як ви створили модуль і налаштували конфігурацію, ви можете застосувати його до сервера. Для цього запустіть команду:

```bash
sudo puppet apply -e "include myorg::apache"
```

## Перевірка
Після виконання цих кроків, ви можете перевірити, чи Apache працює, відкривши веб-браузер і перейшовши за адресою http://localhost. Якщо все налаштовано правильно, ви повинні побачити сторінку Apache.

## Факти в Puppet
Факти (facts) у Puppet — це інформація про вузли (агенти), яка зберігається у вигляді ключ-значення. Ці факти збираються за допомогою інструменту Facter і використовуються для прийняття рішень під час управління конфігурацією.

Факти можуть бути стандартними, такі як версія операційної системи, IP-адреса, кількість процесорів, але також користувач може створювати власні факти для конкретних потреб.

### Приклад стандартних фактів:
  - `os`: інформація про операційну систему (назва, реліз).
  - `ipaddress`: IP-адреса машини.
  - `memory`: інформація про оперативну пам'ять.
  - `hostname`: ім'я вузла.
  - `processorcount`: кількість процесорів.
    
### Створення користувацьких фактів:
Користувацькі факти можна створювати як у вигляді простих файлів з Ruby-кодом, так і через Puppet-файли.

## Синтаксис

У Puppet є кілька способів використовувати факти й працювати з умовними логічними конструкціями. Ось різні варіанти синтаксису для використання фактів та умов у Puppet.

1. Просте використання ресурсу
   
   Найпростіший спосіб використання ресурсу в Puppet — це визначення ресурсу без умов.

```puppet
package { 'vim':
  ensure => installed,
}
```
   У цьому прикладі пакет vim буде встановлено незалежно від будь-яких умов.

2. Умовні конструкції (if-else)
   
   Конструкція if-else дозволяє виконувати умови на основі фактів або змінних.

```puppet
if $facts['os']['name'] == 'Ubuntu' {
  package { 'apache2':
    ensure => installed,
  }
} else {
  package { 'httpd':
    ensure => installed,
  }
}
```
   У цьому прикладі залежно від операційної системи буде встановлено або apache2, або httpd.

3. Використання фактів з розгалуженням (if)
   
```puppet
if $facts['is_virtual'] {
  package { 'qemu-guest-agent':
    ensure => installed,
  }
}
```
   У цьому прикладі, якщо система є віртуальною, буде встановлено пакет qemu-guest-agent.

4. Конструкція unless
   
   unless працює аналогічно до if, але умова заперечується.

```puppet
unless $facts['os']['name'] == 'Ubuntu' {
  package { 'vim-enhanced':
    ensure => installed,
  }
}
```
   Цей код встановлює vim-enhanced, якщо ОС не є Ubuntu.

5. Конструкція case
   
   Конструкція case зручна для перевірки кількох варіантів.

```puppet
case $facts['os']['name'] {
  'Ubuntu': {
    package { 'apache2':
      ensure => installed,
    }
  }
  'CentOS': {
    package { 'httpd':
      ensure => installed,
    }
  }
  default: {
    package { 'nginx':
      ensure => installed,
    }
  }
}
```
   Цей код встановлює apache2 для Ubuntu, httpd для CentOS, а для інших систем — nginx.

6. Використання selector для вибору значень
   
   Selector дозволяє вам задавати значення на основі умови без використання явних розгалужень if.

```puppet
$webserver_package = $facts['os']['name'] ? {
  'Ubuntu' => 'apache2',
  'CentOS' => 'httpd',
  default  => 'nginx',
}

package { $webserver_package:
  ensure => installed,
}
```
   У цьому прикладі змінна $webserver_package отримує різні значення залежно від ОС, і пакет вибирається автоматично.

7. Декларативний стиль без розгалуження
   
   Іноді розгалуження не потрібне. Наприклад, при роботі з простими ресурсами.

```puppet
user { 'john':
  ensure     => present,
  managehome => true,
  home       => '/home/john',
}

file { '/home/john/.bashrc':
  ensure  => file,
  content => 'export PATH=/usr/local/bin:$PATH',
}
```
   Цей код створює користувача john і задає зміст для його .bashrc.

8. Конструкція defined()
   
   Можна використовувати функцію defined() для перевірки, чи існує ресурс або клас.

```puppet
if ! defined(Package['vim']) {
  package { 'vim':
    ensure => installed,
  }
}
``` 
   Цей код перевіряє, чи не встановлено ще vim, і тільки в такому випадку встановлює його.

9. Логічні операції у конструкціях if
    
   Можна комбінувати кілька умов за допомогою логічних операторів.

```puppet
if $facts['os']['name'] == 'Ubuntu' and $facts['os']['release']['major'] == '20.04' {
  package { 'docker':
    ensure => installed,
  }
}
```
10. Класи та використання фактів у класах
    
   Ви можете використовувати факти й умови в класах для створення більш складної конфігурації.

```puppet
class webserver {
  case $facts['os']['name'] {
    'Ubuntu': {
      package { 'apache2':
        ensure => installed,
      }
    }
    'CentOS': {
      package { 'httpd':
        ensure => installed,
      }
    }
  }
}

include webserver
```
   У цьому прикладі клас webserver налаштовує різні пакети залежно від ОС.

### Підсумок
- `Простий ресурс`: Використовується для створення/керування одним ресурсом без умов.
- `if-else`: Використовується для умовної логіки.
- `unless`: Виконує ресурс, якщо умова не виконується.
- `case`: Кілька варіантів умов для вибору дій.
- `selector`: Спрощений синтаксис для вибору значення без явного розгалуження.
- `defined()`: Перевірка, чи існує вже ресурс.
- `Логічні оператори`: Використання and, or для комбінування умов.
- `Класи`: Використання класів для структурування коду та умов.

Ці конструкції дозволяють будувати гнучкі маніфести Puppet для управління конфігураціями систем.

## Лялькові модулі
Лялькові модулі (Puppet modules) - це самостійні блоки, що містять ресурси та визначення, які виконують певні функції або налаштування.

### Структура лялькового модуля
Ось основні компоненти структури лялькового модуля:

- Назва модуля:

  Ім'я модуля зазвичай пишеться в нижньому регістрі. Наприклад, для модуля, який керує установкою Nginx, ім'я може бути nginx.

- Основна директорія модуля:

  Кожен модуль містить свою власну директорію з іменем модуля.
```bash
/etc/puppetlabs/code/environments/production/modules/nginx/
```

- Файл init.pp:

  Цей файл є основним файлом модуля. Він містить визначення класу, яке виконує основну функціональність модуля. Наприклад:
```puppet
class nginx {
    package { 'nginx':
        ensure => installed,
    }

    service { 'nginx':
        ensure => running,
        enable => true,
    }

    file { '/etc/nginx/nginx.conf':
        source => 'puppet:///modules/nginx/nginx.conf',
        notify => Service['nginx'],
    }
}
```

- Файл metadata.json:

   Цей файл містить метадані про модуль, такі як його версія, автор, залежності та інші деталі. Наприклад:
```json
{
    "name": "nginx",
    "version": "1.0.0",
    "author": "Your Name",
    "license": "Apache-2.0",
    "dependencies": [],
    "summary": "A Puppet module for managing Nginx."
}
```

- Директорії manifests/:

  Ця директорія містить файли з визначеннями класів, ресурсів або певних функцій. Додаткові файли можуть бути створені для організації коду.
```bash
/etc/puppetlabs/code/environments/production/modules/nginx/manifests/
```

- Директорії files/:

  Ця директорія містить статичні файли, такі як конфігураційні файли, які можуть бути використані у вашому модулі.
```bash
/etc/puppetlabs/code/environments/production/modules/nginx/files/
```

- Директорії templates/:

  Ця директорія містить шаблони (зазвичай в форматі ERB), які використовуються для генерації конфігураційних файлів на основі значень змінних. Наприклад:
```bash
/etc/puppetlabs/code/environments/production/modules/nginx/templates/
```

- Директорії tests/ (необов'язково):

  Ця директорія може містити файли для тестування модуля, що дозволяє забезпечити його правильність перед використанням.

### Приклад структури модуля Nginx
```csharp
nginx/
├── manifests/
│   └── init.pp
├── files/
│   └── nginx.conf
├── templates/
│   └── nginx.conf.erb
└── metadata.json
```

## Лялькові вузли
Лялькові вузли (Puppet Nodes) — це окремі системи або сервери, на яких застосовуються правила конфігурації, визначені в Puppet. Кожен ляльковий вузол може мати свої специфічні налаштування, програми та ресурси, які він повинен підтримувати. Лялькові вузли підключаються до Puppet-сервера, отримують конфігурації (маніфести) і реалізують їх, щоб відповідати бажаному стану.

### Основні характеристики:

1. Клієнт-серверна архітектура:

  - Вузли зв'язуються з сервером Puppet для отримання конфігураційних даних.
  - Сервер Puppet (майстер) зберігає маніфести, модулі та дані, які описують, як налаштувати різні елементи системи.

2. Агент:

  - На кожному вузлі встановлений агент Puppet, який відповідає за отримання і виконання конфігураційних інструкцій.
  - Агент періодично запитує у сервера нові конфігураційні дані і застосовує їх.

3. Идентифікація:

  - Вузли ідентифікуються за своїми назвами (наприклад, через DNS або за допомогою фіксованих імен).
  - Ідентифікація використовується для застосування специфічних конфігурацій, які можуть бути різними для різних вузлів.

4. Конфігурація:

  - Вузли можуть отримувати конфігураційні дані на основі їхніх імен, класів, факту або інших параметрів.
  - Використовуючи специфічні правила в маніфестах, можна визначити, які ресурси застосовуються до яких вузлів.

### Приклади використання:

- Веб-сервери:

Вузол, що є веб-сервером, може мати встановлені та налаштовані пакети, такі як Apache або Nginx, через Puppet.

- Бази даних:

Вузол, що виконує роль сервера бази даних, може отримати конфігурацію для встановлення і налаштування MySQL або PostgreSQL.

- Системи моніторингу:

Вузли, що забезпечують моніторинг, можуть отримувати інструкції для встановлення і налаштування таких інструментів, як Nagios або Prometheus.

### Що важливо знати про маріонеткові вузли:

- Ролі та профілі:

Часто використовують концепції ролей і профілів для управління конфігурацією вузлів, що спрощує управління великими інфраструктурами.

- Факти:

Puppet збирає факти про вузли, такі як версія ОС, тип архітектури та інші параметри. Ці факти можуть бути використані для умовного застосування конфігурацій.

- Безпека:

Вузли повинні бути належним чином захищені, оскільки вони можуть містити чутливі дані та конфігурації.

- Відстеження змін:

Puppet дозволяє вести журнал змін на вузлах, що допомагає у відстеженні та аудиті конфігурацій.

- Масштабування:

Puppet підходить для управління великою кількістю вузлів, що дозволяє автоматизувати та спростити процеси управління в масштабах підприємства.

### Приклади
- Оголошення лялькового вузла у site.pp:

```puppet
node 'webserver.example.com' {
    include apache
}

node 'dbserver.example.com' {
    include mysql
}
```

У цьому прикладі webserver.example.com отримує конфігурацію для веб-сервера Apache, тоді як dbserver.example.com отримує конфігурацію для MySQL.

- Використання параметрів для лялькових вузлів:

```puppet
node 'appserver.example.com' {
    class { 'nginx':
        port => 80,
        server_name => 'app.example.com',
    }
}
```

Тут ми налаштовуємо ляльковий вузол appserver.example.com для запуску сервера Nginx на порту 80 з вказаним ім'ям сервера.

- Групування лялькових вузлів за класами:

```puppet
node 'dev.example.com', 'test.example.com', 'prod.example.com' {
    include web_app
}
```

В цьому прикладі кілька лялькових вузлів (dev, test, prod) підключені до одного класу web_app, що дозволяє одночасно застосовувати спільні налаштування для всіх цих вузлів.

### Важливі аспекти
- Унікальність: Кожен ляльковий вузол може мати свої специфічні параметри, залежності та конфігурації, що дозволяє легко управляти різними системами.

- Централізоване управління: Лялькові вузли отримують конфігурації з центрального Puppet-сервера, що забезпечує узгодженість і контроль.

- Динамічна конфігурація: Завдяки використанню фактов (facts) Puppet може адаптувати конфігурації під різні умови середовища.

## Модифікація та тестування маніфестів у Puppet
Маніфести — це файли конфігурації в Puppet, які описують, як повинні бути налаштовані різні ресурси на серверах. Модифікація маніфестів і їх тестування є важливими етапами управління конфігурацією, оскільки вони дозволяють забезпечити правильність налаштувань та уникнути помилок.

### Модифікація маніфестів
1. Зміна атрибутів: Ви можете змінювати атрибути ресурсів у маніфестах, такі як ensure, name, source, mode та інші, щоб відповідати новим вимогам.

Приклад:

```puppet
file { '/etc/myconfig.conf':
  ensure => file,
  source => 'puppet:///modules/my_module/myconfig.conf',
  mode   => '0644',
}
```
2. Додавання нових ресурсів: Ви можете додати нові ресурси до маніфестів, щоб налаштувати додаткові компоненти вашої системи.

Приклад:

```puppet
package { 'httpd':
  ensure => installed,
}
```
3. Видалення ресурсів: Якщо ресурс більше не потрібен, ви можете видалити його з маніфесту або встановити атрибут ensure в absent.

Приклад:

```puppet
package { 'httpd':
  ensure => absent,
}
```

4. Використання умовних конструкцій: Для динамічної зміни конфігурацій можна використовувати умовні конструкції на основі фактів системи.

Приклад:

```puppet
if $facts['os']['family'] == 'Debian' {
  package { 'apache2':
    ensure => installed,
  }
} else {
  package { 'httpd':
    ensure => installed,
  }
}
```

### Тестування маніфестів
Тестування маніфестів є важливим для забезпечення їхньої правильності та запобігання помилкам при розгортанні.

1. Puppet Lint: Це інструмент, який перевіряє синтаксис і стиль ваших маніфестів на предмет помилок і потенційних проблем. Використання puppet-lint може допомогти виявити проблеми до виконання коду.

Команда для запуску:

```bash
puppet-lint /path/to/your/manifests/*.pp
```

2. Puppet Parser: Ви можете використовувати puppet parser validate для перевірки правильності синтаксису маніфестів.

Команда для запуску:

```bash
puppet parser validate /path/to/your/manifests/*.pp
```

3. Тестування в середовищі розробки: Перед впровадженням змін у продуктивне середовище рекомендується протестувати маніфести в середовищі розробки або на тестових вузлах.

4. Використання модулів для тестування: Є кілька модулів, як-от rspec-puppet, які дозволяють писати тести для ваших маніфестів. Це допоможе автоматизувати процес тестування та переконатися, що зміни не порушують існуючу функціональність.

Приклад тесту (Ruby):

```ruby
require 'spec_helper'

describe 'my_module::my_class' do
  let(:facts) { { osfamily: 'Debian' } }

  it { should compile.with_all_deps }

  it { should contain_package('apache2').with_ensure('installed') }
end
```

5. Перевірка стану: Після застосування змін у конфігурації за допомогою агента Puppet, важливо перевірити, чи всі ресурси знаходяться в бажаному стані, використовуючи команду
   ```bash
   puppet agent --test`
   ```
