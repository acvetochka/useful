
## Decorator

Декоратор Python — це спеціальна функція, яка дозволяє змінювати або розширювати поведінку інших функцій або методів. Він обертає іншу функцію (або клас) і дозволяє виконати якийсь код до або після основної функції, не змінюючи її.

Основні особливості декораторів:
1️⃣ Перетворення функцій:
Декоратори можуть змінювати поведінку функції, не змінюючи її код.

2️⃣ Повторне використання коду:
Вони дозволяють використовувати спільний код у кількох функціях, зменшуючи дублювання.

3️⃣ Синтаксична зручність:
Python декоратори можуть бути застосовані до функції з використанням символу @, що робить код більш читабельним і елегантним.

```python
# @param func - це функція яка передається в декоратор

def decorator(func):
    # В функції wrapper передаються параметри функції і він викликає цю функцію 
    def wrapper(*agrs, **kwargs):
        print('Before')
        func(*args, **kwargs)
        print('After')
    return wrapper

@decorator
def func():
    print('Hello from func!')

func() 
# виведе: 
# Before
# Hello from func!
# After
```

## Python Generators

Генератор Python – це спеціальний тип функцій, який дозволяє вам повертати значення і пізніше продовжити виконання функції з того місця, де вона була зупинена. Це досягається за допомогою ключового слова yield .

Головна відмінність генератора від звичайної функції полягає в тому, що генератор повертає об'єкт, що ітерується, через який можна пройти тільки один раз. Це дозволяє ефективно працювати з даними, не завантажуючи повністю їх на згадку. Це особливо корисно, коли вам потрібно працювати з великими обсягами даних, або коли ви не знаєте заздалегідь, скільки елементів вам знадобиться.

➕ Приклад використання генератора:
```python
def count_up_to(max):
count = 1
while count <= max:
yield count
count += 1

counter = count_up_to(5)
for num in counter:
print(num)
```
У цьому прикладі функція count_up_to є генератором. Коли ви викликаєте її, вона не виконує свій код одразу. Натомість, вона повертає об'єкт, що ітерується. Коли ви ітерируете через цей об'єкт (наприклад, використовуючи цикл for ), код всередині функції виконується до першого yield . Значення, яке слідує за yield , повертається в цикл. При наступній ітерації виконання функції відновлюється відразу після yield і продовжується до наступного yield .

Використання генераторів дозволяє заощадити ресурси, оскільки значення генеруються за необхідності, а чи не зберігаються у пам'яті.

В асинхронних функціях ( async def ) використовується await замість yield , але концептуально це дуже схоже. Коли функція досягає await , вона повертає керування зухвалій стороні, дозволяючи іншим завданням виконуватися, поки поточне завдання перебуває в очікуванні (наприклад, очікує відповіді від сервера).

➕ Приклад асинхронної функції:
```python
import asyncio

async def fetch_data():
print('Start fetching')
await asyncio.sleep(2) # Імітація асинхронного завдання, наприклад, запиту до сервера
print('Done fetching')
return {'data': 1}

async def main():
print('Before fetching')
result = await fetch_data()
print('Result:', result)
print('After fetching')

asyncio.run(main())
```
Тут fetch_data є асинхронною функцією. Коли вона досягає рядка await asyncio.sleep(2) , керування повертається в main , дозволяючи виконувати інші операції, в той час як fetch_data знаходиться в очікуванні.

Таким чином, генератори та асинхронні функції дозволяють Python більш ефективно використовувати однопоточну модель виконання, надаючи механізм для конкурентного виконання завдань, особливо в ситуаціях, коли багато часу йде на очікування вводу/виводу.

### Підсумок:

Генератор Python - це інструмент для створення ітератора, який можна перебирати (ітерувати) один раз. Генератори використовуються для більш ефективної роботи з даними, дозволяючи не завантажувати всі дані на згадку відразу.
