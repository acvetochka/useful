# Functions

## 1. Визначення функції
Функція в Python — це блок коду, який виконує певну задачу, і може бути повторно використаний у різних частинах програми. Функції допомагають організувати код, роблять його читабельнішим і дозволяють уникати повторення коду.

## 2. Створення функції
Функції створюються за допомогою ключового слова def, після якого йде ім'я функції, список параметрів у дужках та двокрапка.

**Синтаксис:**
```python
def function_name(parameters):
    """Документування функції (необов'язково)"""
    # Код функції
    return result  # (необов'язково)
```
**Приклад:**
```python
def greet(name):
    """Вітає користувача за ім'ям."""
    return f"Привіт, {name}!"
```

## 3. Виклик функції
Для виклику функції використовується її ім'я з переданими аргументами.

**Приклад:**
```python
print(greet("Іван"))  # Виведе: Привіт, Іван!
```

## 4. Аргументи функції
Функції можуть приймати аргументи, які можуть бути обов'язковими або необов'язковими.

### 4.1. Позиційні аргументи
Це аргументи, які передаються функції у визначеному порядку.

**Приклад:**
```python
def add(a, b):
    return a + b

result = add(3, 5)  # result = 8
```

### 4.2. Іменовані (ключові) аргументи
Це аргументи, які передаються за допомогою імені параметра.

**Приклад:**
```python
def describe_pet(animal_type, pet_name):
    print(f"Я маю {animal_type} на ім'я {pet_name}.")

describe_pet(animal_type="собака", pet_name="Бобік")
```

### 4.3. Необов'язкові аргументи з значенням за замовчуванням
Ці аргументи можуть мати значення за замовчуванням, яке використовується, якщо аргумент не передано.

**Приклад:**
```python
def greet(name, greeting="Привіт"):
    return f"{greeting}, {name}!"

print(greet("Оля"))  # Виведе: Привіт, Оля!
print(greet("Оля", "Добрий день"))  # Виведе: Добрий день, Оля!
```

## 5. Повернення значення з функції
Функція може повертати значення за допомогою ключового слова return. Повернення з функції завершує її виконання.

**Приклад:**
```python
def square(x):
    return x ** 2

result = square(4)  # result = 16
```

## 6. Локальні та глобальні змінні
Змінні, оголошені всередині функції, є локальними та доступні лише в цій функції. Глобальні змінні доступні в будь-якій частині програми.

**Приклад:**
```python
x = 10  # Глобальна змінна

def function():
    y = 5  # Локальна змінна
    print(x)  # Доступ до глобальної змінної

function()
print(y)  # Викликає помилку: y не визначена
```

## 7. Анонімні функції (лямбда-функції)
Анонімні функції, або лямбда-функції, — це функції, які не мають імені і визначаються за допомогою ключового слова lambda.

**Синтаксис:**
```python
lambda arguments: expression
```

**Приклад:**
```python
add = lambda x, y: x + y
print(add(2, 3))  # Виведе: 5
```

## 8. Функції вищого порядку
Функції вищого порядку — це функції, які можуть приймати інші функції як аргументи або повертати їх.

**Приклад:**
```python
def apply_function(f, value):
    return f(value)

result = apply_function(square, 5)  # result = 25
```

## 9. Документування функцій
Документація функцій забезпечує опис того, що робить функція, її параметри та значення, що повертається. Вона записується в рядок документації (docstring), що розташовується відразу після заголовка функції.

**Приклад:**
```python
def multiply(a, b):
    """Повертає добуток a та b."""
    return a * b
```
    

## Decorator

Декоратор Python — це спеціальна функція, яка дозволяє змінювати або розширювати поведінку інших функцій або методів. Він обертає іншу функцію (або клас) і дозволяє виконати якийсь код до або після основної функції, не змінюючи її.

Основні особливості декораторів:
1️⃣ Перетворення функцій:
Декоратори можуть змінювати поведінку функції, не змінюючи її код.

2️⃣ Повторне використання коду:
Вони дозволяють використовувати спільний код у кількох функціях, зменшуючи дублювання.

3️⃣ Синтаксична зручність:
Python декоратори можуть бути застосовані до функції з використанням символу @, що робить код більш читабельним і елегантним.

```python
# @param func - це функція яка передається в декоратор

def decorator(func):
    # В функції wrapper передаються параметри функції і він викликає цю функцію 
    def wrapper(*agrs, **kwargs):
        print('Before')
        func(*args, **kwargs)
        print('After')
    return wrapper

@decorator
def func():
    print('Hello from func!')

func() 
# виведе: 
# Before
# Hello from func!
# After
```

## Python Generators

Генератор Python – це спеціальний тип функцій, який дозволяє вам повертати значення і пізніше продовжити виконання функції з того місця, де вона була зупинена. Це досягається за допомогою ключового слова yield .

Головна відмінність генератора від звичайної функції полягає в тому, що генератор повертає об'єкт, що ітерується, через який можна пройти тільки один раз. Це дозволяє ефективно працювати з даними, не завантажуючи повністю їх на згадку. Це особливо корисно, коли вам потрібно працювати з великими обсягами даних, або коли ви не знаєте заздалегідь, скільки елементів вам знадобиться.

➕ Приклад використання генератора:
```python
def count_up_to(max):
count = 1
while count <= max:
yield count
count += 1

counter = count_up_to(5)
for num in counter:
print(num)
```
У цьому прикладі функція count_up_to є генератором. Коли ви викликаєте її, вона не виконує свій код одразу. Натомість, вона повертає об'єкт, що ітерується. Коли ви ітерируете через цей об'єкт (наприклад, використовуючи цикл for ), код всередині функції виконується до першого yield . Значення, яке слідує за yield , повертається в цикл. При наступній ітерації виконання функції відновлюється відразу після yield і продовжується до наступного yield .

Використання генераторів дозволяє заощадити ресурси, оскільки значення генеруються за необхідності, а чи не зберігаються у пам'яті.

В асинхронних функціях ( async def ) використовується await замість yield , але концептуально це дуже схоже. Коли функція досягає await , вона повертає керування зухвалій стороні, дозволяючи іншим завданням виконуватися, поки поточне завдання перебуває в очікуванні (наприклад, очікує відповіді від сервера).

➕ Приклад асинхронної функції:
```python
import asyncio

async def fetch_data():
print('Start fetching')
await asyncio.sleep(2) # Імітація асинхронного завдання, наприклад, запиту до сервера
print('Done fetching')
return {'data': 1}

async def main():
print('Before fetching')
result = await fetch_data()
print('Result:', result)
print('After fetching')

asyncio.run(main())
```
Тут fetch_data є асинхронною функцією. Коли вона досягає рядка await asyncio.sleep(2) , керування повертається в main , дозволяючи виконувати інші операції, в той час як fetch_data знаходиться в очікуванні.

Таким чином, генератори та асинхронні функції дозволяють Python більш ефективно використовувати однопоточну модель виконання, надаючи механізм для конкурентного виконання завдань, особливо в ситуаціях, коли багато часу йде на очікування вводу/виводу.

### Підсумок:

Генератор Python - це інструмент для створення ітератора, який можна перебирати (ітерувати) один раз. Генератори використовуються для більш ефективної роботи з даними, дозволяючи не завантажувати всі дані на згадку відразу.
