# Робота з файлами <!-- omit in toc -->

  ## Зміст <!-- omit in toc -->
- [Розділ 1: Робота з деревом файлів](#розділ-1-робота-з-деревом-файлів)
  - [1.1. pwd (Print Working Directory)](#11-pwd-print-working-directory)
  - [1.2. cd (Change Directory)](#12-cd-change-directory)
  - [1.3. ls (List)](#13-ls-list)
  - [1.4. mkdir (Make Directory)](#14-mkdir-make-directory)
  - [1.5. cp (Copy)](#15-cp-copy)
  - [1.6. mv (Move)](#16-mv-move)
  - [1.7. rm (Remove)](#17-rm-remove)
  - [1.8. tree](#18-tree)
  - [1.9. Використання метасимволів (Wildcards)](#19-використання-метасимволів-wildcards)
  - [1.10. Розширення фігурних дужок (Brace Expansion)](#110-розширення-фігурних-дужок-brace-expansion)
  - [1.11. Спеціальні випадки та комбінації](#111-спеціальні-випадки-та-комбінації)
    - [А. Копіювання вмісту папки (символ /)](#а-копіювання-вмісту-папки-символ-)
    - [Б. Робота з іменами, що містять пробіли](#б-робота-з-іменами-що-містять-пробіли)
    - [В. "Розумне" видалення та безпека](#в-розумне-видалення-та-безпека)
    - [Г. Потужне перейменування (rename / mmv)](#г-потужне-перейменування-rename--mmv)
  - [1.12. Перевірка дискового простору в дереві](#112-перевірка-дискового-простору-в-дереві)
- [Розділ 2: Посилання (Links)](#розділ-2-посилання-links)
  - [2.1. ln (Link)](#21-ln-link)
  - [2.2. Жорсткі посилання (Hard Links)](#22-жорсткі-посилання-hard-links)
  - [2.3. Символічні посилання (Symbolic/Soft Links)](#23-символічні-посилання-symbolicsoft-links)
  - [2.4. Як розрізнити посилання (Аналіз)](#24-як-розрізнити-посилання-аналіз)
  - [2.5. Специфічні випадки та операції](#25-специфічні-випадки-та-операції)
    - [А. Видалення посилань](#а-видалення-посилань)
    - [Б. Знаходження всіх жорстких посилань на файл](#б-знаходження-всіх-жорстких-посилань-на-файл)
    - [В. Перевірка "битих" посилань](#в-перевірка-битих-посилань)
    - [Г. Відносні vs Абсолютні шляхи](#г-відносні-vs-абсолютні-шляхи)
    - [Д. Символічні посилання та cd](#д-символічні-посилання-та-cd)
- [Розділ 3: Перегляд вмісту та редагування](#розділ-3-перегляд-вмісту-та-редагування)
  - [3.1. Швидкий вивід (Non-interactive)](#31-швидкий-вивід-non-interactive)
  - [3.2. Інтерактивний перегляд (Pagers)](#32-інтерактивний-перегляд-pagers)
  - [3.3. Редагування файлів](#33-редагування-файлів)
  - [3.4. Специфічні випадки та маніпуляції](#34-специфічні-випадки-та-маніпуляції)
    - [А. Створення файлу "на льоту"](#а-створення-файлу-на-льоту)
    - [Б. Перегляд бінарних файлів](#б-перегляд-бінарних-файлів)
    - [В. Редагування без відкриття (sed)](#в-редагування-без-відкриття-sed)
    - [Г. Порівняння файлів](#г-порівняння-файлів)
  - [3.5. Додаткові утиліти перегляду та аналізу](#35-додаткові-утиліти-перегляду-та-аналізу)
  - [3.6. Потужні інструменти трансформації (sed, awk)](#36-потужні-інструменти-трансформації-sed-awk)
  - [3.7. Регулярні вирази (Regex)](#37-регулярні-вирази-regex)
- [Розділ 4: Пошук (Files \& Content)](#розділ-4-пошук-files--content)
  - [4.1. find (Універсальний пошук файлів)](#41-find-універсальний-пошук-файлів)
  - [4.2. grep (Global Regular Expression Print)](#42-grep-global-regular-expression-print)
  - [4.3. locate (Миттєвий пошук за базою)](#43-locate-миттєвий-пошук-за-базою)
  - [4.4. which та whereis (Пошук програм)](#44-which-та-whereis-пошук-програм)
  - [4.5. Утиліта xargs](#45-утиліта-xargs)
  - [4.6. Специфічні комбінації (Pro-level)](#46-специфічні-комбінації-pro-level)
    - [А. Пошук і заміна (find + sed)](#а-пошук-і-заміна-find--sed)
    - [Б. Пошук тексту тільки у специфічних файлах (grep + find)](#б-пошук-тексту-тільки-у-специфічних-файлах-grep--find)



## Розділ 1: Робота з деревом файлів

У цьому розділі ми розглянемо основні утиліти: `pwd`, `cd`, `ls`, `mkdir`, `rmdir`, `cp`, `mv`, `rm` та `tree`.

### 1.1. pwd (Print Working Directory)
Показує повний абсолютний шлях до поточної директорії, в якій знаходиться користувач.

Аргументи:
- `-L` (Logical): Використовувати шлях з оточення, навіть якщо він містить символічні посилання (типово).
- `-P` (Physical): Уникати символічних посилань і показувати реальний фізичний шлях на диску.

Приклад:

- `pwd` — результат: `/home/user/documents`
- `pwd -P` — якщо ви в папці-посиланні, покаже справжню адресу папки.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 1.2. cd (Change Directory)
Команда для переміщення між директоріями.

Спеціальні символи:
- `cd ~` або просто `cd` — перехід у домашню директорію користувача.
- `cd ..` — перехід на один рівень вгору.
- `cd -` — повернення до попередньої директорії (аналог кнопки "Назад").
- `cd /` — перехід у корінь системи.

Приклад:
- `cd /var/log` — перехід за абсолютном шляхом.
- `cd ./projects` — перехід у папку projects всередині поточної.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 1.3. ls (List)
Виводить список файлів та підкаталогів. Одна з найбільш вживаних команд.

Аргументи:
- `-l` (long): Детальний список (права доступу, власник, розмір, дата).
- `-a` (all): Показувати приховані файли (ті, що починаються з крапки .).
- `-h` (human-readable): Відображати розмір файлів у зрозумілих одиницях (КБ, МБ, ГБ).
- `-R` (recursive): Рекурсивний вивід усіх підпапок.
- `-t` (time): Сортувати за часом останньої зміни.
- `-S`: Сортувати за розміром.

Приклад:
- `ls -lah` — вивести абсолютно всі файли з детальною інформацією у зручному форматі.
- `ls -lt /etc` — подивитися останні змінені конфігураційні файли.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 1.4. mkdir (Make Directory)
Створення нових папок.

Аргументи:
- `-p` (parents): Створює весь ланцюжок вкладених папок, якщо вони не існують.
- `-m` (mode): Встановити права доступу (chmod) відразу при створенні.

Приклад:
- `mkdir project` — створення папки в поточній директорії.
- `mkdir -p site/assets/images` — створить три папки одну в одній одним махом.
- `mkdir -m 777 public_folder` — створить папку з повним доступом для всіх.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 1.5. cp (Copy)
Копіювання файлів та директорій.

Аргументи:
- `-r` або `-R` (recursive): Обов'язковий для копіювання папок з їхнім вмістом.
- `-i` (interactive): Питати підтвердження перед перезаписом.
- `-u` (update): Копіювати тільки якщо вихідний файл новіший за існуючий.
- `-p` (preserve): Зберегти атрибути файлу (час, права доступу).

Приклад:
- `cp file.txt backup.txt` — копіювання файлу.
- `cp -r /home/user/work /media/usb/` — копіювання всієї папки на флешку.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 1.6. mv (Move)
Переміщення або перейменування файлів та папок.

Аргументи:
- `-i` (interactive): Запит на підтвердження перед заміною.
- `-n` (no-clobber): Не перезаписувати існуючі файли.
- `-v` (verbose): Показувати, що саме відбувається в процесі.

Приклад:
- `mv old_name.txt new_name.txt` — перейменування.
- `mv document.pdf ~/Documents/` — переміщення у вказану папку.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 1.7. rm (Remove)
Видалення файлів та директорій. Обережно: в терміналі немає "Кошика"!

Аргументи:
- `-r` (recursive): Видалення папки та всього її вмісту.
- `-f` (force): Видалити без запитів ігноруючи помилки.
- `-i`: Питати дозвіл перед кожним видаленням.

Приклад:
- `rm script.sh` — видалення файлу.
- `rm -rf project_folder` — повне видалення папки без зайвих питань (використовувати вкрай обережно).

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 1.8. tree
Візуалізація дерева файлів.

Аргументи:
- `-L [depth]`: Обмежити глибину відображення (наприклад, -L 2).
- `-d`: Показувати тільки директорії, ігнорувати файли.
- `-f`: Показувати повний шлях для кожного файлу.

Приклад:
- `tree -L 2` — покаже структуру папок на два рівні вглиб.

Додаємо критично важливий пласт знань про метасимволи (wildcards), дужки та спеціальні оператори, які роблять роботу з деревом файлів у десятки разів швидшою. Без них робота в терміналі — це просто заміна мишки; з ними — це автоматизація.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 1.9. Використання метасимволів (Wildcards)
Це спеціальні символи, які дозволяють виконувати операції над групами файлів, що відповідають певному шаблону.
- `*` (Зірочка): Замінює будь-яку кількість символів (навіть нуль).

  - `ls *.txt` — показати всі текстові файли.
  - `rm -f temp_*` — видалити всі файли, що починаються на "temp_".
  - `cp *.jpg ~/Photos/` — скопіювати всі зображення в папку Photos.
- `?` (Знак питання): Замінює рівно один будь-який символ.
  - `ls file?.log` — знайде `file1.log`, `fileA.log`, але не `file10.log`.
- `[ ]` (Квадратні дужки): Визначають діапазон або набір символів.
  - `ls file[1-3].txt` — знайде file1.txt, file2.txt, file3.txt.
  - `ls [a-z]*.doc` — знайде всі документи, що починаються з малої літери.
  - `ls *.[ch]` — знайде всі файли вихідного коду C (.c або .h).

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 1.10. Розширення фігурних дужок (Brace Expansion)
Це потужний механізм генерації довільних рядків, який часто плутають із метасимволами. Він працює ще до того, як команда почне шукати файли.

Масове створення:
- `mkdir -p project/{src,bin,lib,docs}` — створить одразу 4 підпапки в директорії project.
- `touch file_{1..10}.txt` — миттєво створить 10 файлів від file_1.txt до file_10.txt.

Резервне копіювання:
- `cp config.conf{,.bak}` — швидкий спосіб зробити бекап. Розгорнеться в: `cp config.conf config.conf.bak`.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 1.11. Спеціальні випадки та комбінації

#### А. Копіювання вмісту папки (символ /)

Важливий нюанс у командах `cp` та `rsync`:
- `cp -r folder1 folder2` — скопіює папку folder1 всередину folder2.
- `cp -r folder1/. folder2` — скопіює тільки вміст folder1 безпосередньо в folder2.

#### Б. Робота з іменами, що містять пробіли
Якщо файл називається `My Report.pdf`, команда `rm My Report.pdf` видасть помилку (вона спробує видалити два різні файли: `My` та `Report.pdf`).
- Екранування: `rm My\ Report.pdf` (зворотний слеш перед пробілом).
- Лапки: `rm "My Report.pdf"`.
- Автодоповнення: Натисніть клавішу Tab після перших літер — термінал сам підставить слеші або лапки.

#### В. "Розумне" видалення та безпека
Якщо потрібно видалити все в папці, крім одного файлу (у Bash має бути увімкнено `extglob`):
- `rm !(important.txt)` — видалити все, крім `important.txt`.
- Безпечне видалення: Багато системних адміністраторів замість rm використовують `mv file ~/.trash/` або встановлюють утиліту `trash-cli`, щоб мати можливість відновити файли.

#### Г. Потужне перейменування (rename / mmv)
Якщо mv вміє перейменовувати лише по одному файлу, то спеціальна утиліта rename (або prename) використовує регулярні вирази:
- `rename 's/\.htm$/\.html/' *.htm` — масово змінить розширення всіх файлів з .htm на .html.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 1.12. Перевірка дискового простору в дереві
Перед масовим копіюванням чи видаленням корисно знати "вагу" гілок дерева:

du (Disk Usage):
- `du -sh *` — покаже розмір кожної папки та файлу в поточному каталозі у "людському" форматі.
- `du -ch | tail -1` — покаже загальну вагу всього дерева папок.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

## Розділ 2: Посилання (Links)
Посилання — це спосіб надати одному файлу декілька імен або шляхів. Існує два основних типи: символічні (м'які) та жорсткі.

### 2.1. ln (Link)
Основна утиліта для створення посилань. За замовчуванням створює жорстке посилання.

Синтаксис: `ln [опції] <ціль> <назва_посилання>`

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 2.2. Жорсткі посилання (Hard Links)
Жорстке посилання — це, по суті, ще одне ім'я для тих самих даних на фізичному диску (однаковий номер inode).

Особливості:
- Якщо ви видалите оригінальний файл, дані залишаться доступними через жорстке посилання.
- Дані видаляються з диска лише тоді, коли видалено останнє жорстке посилання на них.
- Обмеження: Не можна створювати для директорій. Не можуть посилатися на файли на іншому диску (файловій системі).

Приклад:
- `ln file.txt hard_link.txt` — створення жорсткого посилання. Тепер обидва файли ідентичні, і зміни в одному відобразяться в іншому.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 2.3. Символічні посилання (Symbolic/Soft Links)
Це спеціальний тип файлу, який містить лише шлях до іншого файлу або директорії (аналог ярлика в Windows).

Аргументи:
- `-s` (symbolic): Створює саме символічне посилання (найпопулярніший варіант).
- `-v` (verbose): Виводить повідомлення про кожне створене посилання.
- `-f` (force): Перезаписати існуюче посилання з таким самим ім'ям.

Особливості:
- Можуть посилатися на директорії.
- Працюють між різними дисками/розділами.
- Якщо видалити оригінал, посилання стане «битим» (pointing to nowhere).

Приклад:
- `ln -s /var/www/html/ my_site` — створення посилання на папку веб-сайту у вашій домашній директорії.
- `ln -s /usr/bin/python3 python` — створення посилання на інтерпретатор.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 2.4. Як розрізнити посилання (Аналіз)
Для перевірки типу посилань використовуйте вже знайому команду ls:
- `ls -l`:
  - Для символічних посилань ви побачите літеру l на початку рядка прав доступу та стрілочку: `lrwxrwxrwx ... my_link -> /path/to/original`
  - Для жорстких посилань число після прав доступу (лічильник посилань) буде більше одиниці.
- `ls -i`:
  - Показує номер inode. У жорстких посилань цей номер буде абсолютно однаковим, у символічних — різним.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 2.5. Специфічні випадки та операції
#### А. Видалення посилань
Для видалення використовується звичайна команда rm, але існує спеціалізована утиліта:
- `unlink my_link` — безпечне видалення посилання. Вона працює тільки з одним посиланням за раз і ніколи не видалить вміст директорії випадково.

#### Б. Знаходження всіх жорстких посилань на файл
Якщо ви хочете дізнатися, де ще в системі є "імена" цього самого файлу:
- `find / -samefile /path/to/file 2>/dev/null` — знайде всі жорсткі посилання за номером inode.

#### В. Перевірка "битих" посилань
Символічні посилання часто ламаються після видалення оригіналів.
- `find . -xtype l` — знайти всі "биті" символічні посилання в поточній папці.

#### Г. Відносні vs Абсолютні шляхи
При створенні символічного посилання краще використовувати абсолютний шлях:
- `ln -s ../file.txt link` — погано: якщо перемістити посилання link в іншу папку, воно зламається.
- `ln -s /home/user/file.txt link` — добре: посилання працюватиме незалежно від свого розташування.

#### Д. Символічні посилання та cd
Коли ви переходите в папку через посилання:
- `cd link_to_dir`
  - pwd покаже шлях через посилання.
  - pwd -P покаже реальне фізичне розташування папки.
 
[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

## Розділ 3: Перегляд вмісту та редагування
Розділимо інструменти на три категорії: швидкий вивід, інтерактивний перегляд та повноцінні редактори.

### 3.1. Швидкий вивід (Non-interactive)
- cat (Concatenate)

  Виводить увесь вміст файлу в термінал одним махом.
  
  Аргументи:
  - `-n`: Нумерація всіх рядків.
  - `-b`: Нумерація тільки непустих рядків.
  - `-s`: Стискати кілька порожніх рядків в один.
  
  Приклад: `cat -n config.txt` — подивитися конфіг з номерами рядків.

- head та tail

  Читання початку або кінця файлу.
  
  Аргументи:
  - `-n [число]`: Кількість рядків (типово 10).
  - `-c [число]`: Кількість байтів.
  - `-f (тільки для tail)`: Режим "follow". Залишає файл відкритим і виводить нові рядки в реальному часі. Незамінно для логів.
  
  Приклад: `tail -f /var/log/syslog` — моніторинг системних подій у реальному часі.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 3.2. Інтерактивний перегляд (Pagers)
- less
  Найпотужніша утиліта для читання великих файлів. Вона не завантажує весь файл у пам'ять, тому відкриває гігабайтні логи миттєво.
  
  Керування всередині less:
  - `Space / b`: Сторінка вперед / назад.
  - `g / G`: Перейти в початок / кінець файлу.
  - `/[текст]`: Пошук тексту. n — наступний збіг, N — попередній.
  - `q`: Вихід.
  
  Приклад: `less +G large_database.sql` — відкрити файл і відразу перейти в кінець.

  Професійний трюк: `З less у vim`

  Якщо ви переглядаєте величезний файл через less і зрозуміли, що в конкретному місці треба внести правку:
  - Знаходячись у less, просто натисніть клавішу `v`.
  - less автоматично відкриє поточний файл у вашому системному редакторі (зазвичай vim) на тому ж самому рядку, де ви зупинилися.
  - Після збереження та виходу з vim (:wq), ви знову опинитеся в less і зможете продовжити читання.
  - Важливо: Для цього має бути встановлена змінна середовища `EDITOR` (зазвичай вона налаштована за замовчуванням).

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 3.3. Редагування файлів
- Nano (Простий)
  Найкращий вибір для швидких правок, якщо ви не хочете вчити складні комбінації.
  
  Гарячі клавіші (показані внизу екрана):
  - `Ctrl + O`: Зберегти зміни.
  - `Ctrl + X`: Вийти (якщо файл змінено, запитає підтвердження).
  - `Ctrl + W`: Пошук слова.
  - `Ctrl + K`: Вирізати рядок.

- Vim (Професійний)
  Редактор з модальним керуванням (вимагає звикання).
  
  Режими:
  - `Normal` (за замовчуванням): Для навігації та видалення.
  - `Insert`: Для введення тексту (натисніть i).
  - `Command`: Для системних дій (натисніть Esc, потім :).
  
  Основні команди:
  - `:w` — зберегти.
  - `:q!` — вийти без збереження.
  - `:wq` — зберегти та вийти.
  - `dd` — видалити рядок.
  
  Інтерактивний підручник `Vim` — найкращий спосіб почати.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 3.4. Специфічні випадки та маніпуляції
#### А. Створення файлу "на льоту"

Необов'язково відкривати редактор, щоб створити короткий файл:
- `echo "my text" > file.txt` — створити файл (або перезаписати існуючий).
- `echo "new line" >> file.txt` — додати рядок у кінець файлу.
- `touch file.txt` — створити порожній файл або оновити дату його зміни.

#### Б. Перегляд бінарних файлів
Якщо відкрити картинку чи програму через cat, термінал "зламається". Використовуйте:
- `od -c [файл]` або `hexdump -C [файл]` — перегляд файлу в шістнадцятковому форматі.

#### В. Редагування без відкриття (sed)
Якщо треба замінити слово "Apple" на "Orange" у 100 файлах:
- `sed -i 's/Apple/Orange/g' *.txt` — команда sed зробить це миттєво без відкриття кожного файлу вручну.

#### Г. Порівняння файлів
- `diff file1.txt file2.txt` — покаже різницю між двома версіями тексту.
- `vimdiff file1.txt file2.txt` — візуальне порівняння у редакторі Vim (дуже зручно).

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 3.5. Додаткові утиліти перегляду та аналізу
- more (Старий колега less)
  Спадкоємець однойменної команди, дозволяє гортати файл лише вперед.
  
  Використання: `more [файл]`
  
  Клавіші: `Space` (наступна сторінка), `Enter` (наступний рядок).
  
  Примітка: В сучасних системах less є функціональнішим замінником.

- file (Визначення типу)
  Оскільки в Linux розширення файлу (.txt, .jpg) є лише частиною імені й не гарантує вміст, file аналізує сигнатуру файлу ("magic bytes").
  
  Аргументи:
  - `-b` (brief): Вивести лише тип без імені файлу.
  - `-i` (mime): Вивести MIME-тип (наприклад, text/plain; charset=utf-8).
  
  Приклад: `file image.png` — покаже реальну роздільну здатність та тип стиснення.

- wc (Word Count)
  Підрахунок статистики файлу.
  
  Аргументи:
  - `-l` (lines): Кількість рядків.
  - `-w` (words): Кількість слів.
  - `-c` (bytes): Кількість байтів.
  - `-m` (chars): Кількість символів.
  
  Приклад: `ls | wc -l` — підрахувати кількість файлів у папці.
- sort (Сортування)

  Аргументи:
  - `-n` (numeric): Сортувати за числовим значенням (інакше "10" буде перед "2").
  - `-r` (reverse): У зворотному порядку.
  - `-u` (unique): Видалити дублікати під час сортування.
  - `-k [N]`: Сортувати за N-м стовпцем.
  
  Приклад: `sort -nr -k 2 data.txt` — сортувати файл за другим стовпцем як числа у зворотному порядку.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 3.6. Потужні інструменти трансформації (sed, awk)
- sed (Stream Editor)
  Потоковий редактор для пошуку та заміни тексту "на льоту".
  
  Синтаксис: `sed 's/шаблон/заміна/прапорець' файл`
  
  Аргументи:
  - `-i`: Зберегти зміни безпосередньо у файл (inplace).
  - `-e`: Дозволяє виконувати кілька команд поспіль.
  
  Приклади:
  - `sed 's/apple/orange/g' fruit.txt` — замінити всі (g - global) "apple" на "orange" при виводі.
  - `sed -i '5d' config.txt` — видалити 5-й рядок у файлі.

- awk (Обробка колонок)
  Мова програмування для вибірки даних зі стовпців.
  
  Синтаксис: `awk 'умова {дія}' файл`
  
  Параметри:
  - `$1, $2...$N`: Звернення до номеру стовпця. $0 — весь рядок.
  - `-F`: Вказати роздільник (типово пробіл).
  
  Приклади:
  - `awk '{print $1, $3}' data.txt` — вивести тільки перший та третій стовпці.
  - `awk -F: '{print $1}' /etc/passwd` — вивести імена користувачів (роздільник :).

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 3.7. Регулярні вирази (Regex)
Це мова шаблонів, яку розуміють `grep`, `sed`, `awk`, `less` та `vim`.

| Символ	| Опис	| Приклад|
| -----|  ------| ------|
| ^	 |Початок рядкаv |	^Error (рядки, що починаються з Error) |
| $ |	Кінець рядка |	!$ (рядки, що закінчуються знаком оклику)|
| . |	Будь-який один символ |	d.g (dog, dig, d-g) |
|*	|0 або більше повторів |	ab* (a, ab, abb, abbb...) |
| +	| 1 або більше повторів	| ab+ (ab, abb... але не a)|
| [a-z] |	Діапазон символів	| [0-9] (будь-яка цифра) |
| \	| Екранування	| \. (шукати саме крапку, а не будь-який символ)|

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

## Розділ 4: Пошук (Files & Content)
У Linux пошук поділяється на два типи: пошук файлів за атрибутами (назва, дата, розмір) та пошук всередині файлів (по тексту).

### 4.1. find (Універсальний пошук файлів)
  Найпотужніша утиліта, яка сканує файлову систему в реальному часі.
  
  Синтаксис: `find [шлях] [критерії] [дії]`
  
  Аргументи:
  - `-name "шаблон"`: Пошук за іменем (чутливий до регістру). -iname — нечутливий.
  - `-type [f/d/l]`: Тип об'єкта: f (файл), d (директорія), l (посилання).
  - `-size [+/-][N][unit]`: Пошук за розміром. +100M (більше 100 МБ), -1k (менше 1 КБ).
  - `-mtime [+/-][N]`: Час модифікації у днях. -7 (за останній тиждень).
  - `-user [username]`: Файли конкретного власника.
  - `-exec [команда] {} \;`: Виконати команду для кожного знайденого файлу.
  
  Приклади:
  - `find . -type f -name "*.log" -size +10M` — знайти всі логи в поточній папці більше 10 МБ.
  - `find /home -user john -iname "*report*"` — знайти всі звіти користувача John.
  - `find /tmp -mtime +30 -delete` — знайти та видалити файли в /tmp, старші за 30 днів.

Докладніше про [find](https://github.com/acvetochka/useful/blob/main/Linux/find.md)

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 4.2. grep (Global Regular Expression Print)
Інструмент для пошуку рядків тексту, що відповідають шаблону (регулярному виразу).

Аргументи:
- `-i`: Ігнорувати регістр букв.
- `-r` або `-R`: Рекурсивний пошук у всіх підпапках.
- `-v`: Інверсія (показати всі рядки, де немає вказаного слова).
- `-l`: Вивести лише імена файлів, де знайдено збіг (без самого тексту).
- `-n`: Показати номер рядка у файлі.
- `-E`: Використовувати розширені регулярні вирази (ERE).
- `-A [N]` / `-B [N]`: Показати N рядків після (After) або до (Before) знайденого збігу.

Приклади:
- `grep -rn "error" /var/log` — знайти всі згадки "error" у системних логах із номерами рядків.
- `grep -v "^#" config.conf` — прочитати конфіг, відфільтрувавши всі закоментовані рядки (що починаються на #).
- `ls -la | grep "Jan"` — відфільтрувати список файлів, створених у січні.

Докладніше про [grep](https://github.com/acvetochka/useful/blob/main/Linux/grep.md)

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 4.3. locate (Миттєвий пошук за базою)
На відміну від `find`, вона не сканує диск, а звертається до підготовленої бази даних `mlocate.db`. Це працює в сотні разів швидше.

Особливості:
- Показує лише шляхи до файлів.
- Не знає про файли, створені сьогодні (база зазвичай оновлюється раз на добу).

Команди:
- `locate "filename"` — швидкий пошук.
- `sudo updatedb` — примусово оновити базу даних прямо зараз, щоб побачити свіжостворені файли.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 4.4. which та whereis (Пошук програм)
Використовуються для пошуку виконуваних файлів команд.

- `which [команда]`: Показує повний шлях до бінарного файлу, який виконається при введенні команди.

  Приклад: `which python3 -> /usr/bin/python3`.

- `whereis [команда]`: Показує шлях до бінарника, вихідного коду та сторінок документації (man pages).

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)

### 4.5. Утиліта xargs
`xargs` (eXtended ARGuments) — це інструмент, який зчитує дані зі стандартного потоку введення (stdin), розбиває їх на окремі аргументи та передає іншій команді.

**Навіщо вона потрібна?**
- Обхід обмежень: У Linux є ліміт на кількість аргументів у команді (помилка Argument list too long). xargs розбиває довгий список на частини.
- Конвеєризація: Багато команд (як-от rm) не вміють читати список файлів прямо з потоку. xargs перетворює текст на аргументи.

**Основні ключі та можливості**
- `-0` (null-separator) — Критично важливий
  За замовчуванням xargs розділяє вхідні дані пробілами або переносами рядків. Якщо у назві файлу є пробіл (наприклад, My Photo.jpg), xargs сприйме це як два файли: My та Photo.jpg.

  Рішення: Використовувати разом із find -print0.

  Приклад: `find . -name "*.txt" -print0 | xargs -0 rm` — безпечне видалення файлів навіть із пробілами в назвах.
- `-p` (interactive) — Безпека понад усе

  Перед виконанням кожної команди xargs запитуватиме підтвердження (y/n).

  Приклад: `find . -name "*.tmp" | xargs -p rm` — видалення з ручним підтвердженням для кожного файлу.
- `-t` (verbose) — Прозорість

  Виводить у термінал фінальну команду, яку він збирається виконати, безпосередньо перед виконанням.

  Приклад: `ls *.log | xargs -t rm` — ви побачите рядок `rm file1.log file2.log`.
- `-n [N]` (max-args) — Покрокове виконання

  Обмежує кількість аргументів, що передаються команді за один раз.

  Приклад: `echo "1 2 3 4" | xargs -n 2 echo`

  Результат: спочатку виконається `echo 1 2`, потім `echo 3 4`.
- `-I` [placeholder] (replace-str) — Гнучкість

  Дозволяє вставити аргумент у будь-яке місце команди, а не тільки в кінець. Зазвичай використовують {} як заглушку.

  Приклад: `find . -name "*.jpg" | xargs -I {} cp {} /backup/photos/` — копіює кожен знайдений файл у вказану папку (тут {} замінюється на ім'я файлу).

- `-P [N]` (parallel) — Швидкість

  Дозволяє запускати кілька процесів одночасно. Ідеально для багатоядерних процесорів.

  Приклад: `find . -name "*.png" | xargs -P 4 -I {} convert {} {}.webp` — конвертація зображень у 4 потоки одночасно.
- `-a [file]` (arg-file)

  Читає аргументи з файлу, а не зі стандартного вводу.

  Приклад: `xargs -a list_of_users.txt mkdir` — створить папки для кожного імені з файлу.

Порівняльна таблиця: `find -exec`проти `xargs`
| Характеристика	| find -exec	| find xargs |
| -------------- | -------------| ---------- |
| Швидкість	| Повільніше (запускає новий процес для кожного файлу) |	Швидше (групує файли в одну команду)	|
| Пробіли в назвах	| Обробляє автоматично	| Потребує ключів -0 та -print0	|
| Паралелізм	| Ні	| Так (ключ -P)|	
| Складність	| Простіше для одиночних дій	| Гнучкіше для складних конвеєрів	|

Практичні сценарії використання xargs
- Масове перейменування (додавання префіксу):
  ```bash
  ls *.txt | xargs -I {} mv {} old_{}
  ```
- Пошук тексту у файлах, знайдених за назвою:
  ```bash
  find . -name "*.conf" | xargs grep "timeout"
  ```
- Видалення всіх порожніх файлів у системі:
  ```bash
  find . -type f -empty | xargs rm
  ```
- Створення архівів для кожної папки окремо:
  ```bash
  ls -d */ | xargs -I {} tar -cvzf {}.tar.gz {}
  ```

### 4.6. Специфічні комбінації (Pro-level)
#### А. Пошук і заміна (find + sed)
Якщо треба замінити текст у багатьох файлах, розкиданих по дереву:
- `find . -type f -name "*.txt" -exec sed -i 's/old/new/g' {} +`

  Пояснення: find знаходить файли, а sed проводить заміну всередині кожного.

#### Б. Пошук тексту тільки у специфічних файлах (grep + find)
- `grep -r "API_KEY" $(find src/ -name "*.js")`

  Шукає ключ тільки всередині JavaScript файлів у папці src.

[Назад до змісту](#%D0%B7%D0%BC%D1%96%D1%81%D1%82-)
