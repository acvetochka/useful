# Команда du

Команда du (disk usage) — це стандартний інструмент Linux/Unix для оцінки обсягу дискового простору, який займають файли та директорії.

Ось детальний розбір її роботи та параметрів.

## 1. Синтаксис
```bash
du [аргументи] [шлях_до_файлу_або_папки]
```
Будьте обачні, використовуючи код.

Якщо шлях не вказано, команда аналізує поточну директорію.

## 2. Основні аргументи (Найуживаніші)
- `-h (human-readable)`: Виводить розмір у зручному форматі (K, M, G). Без цього прапорця розмір виводиться в блоках (зазвичай по 1024 байти).
- `-s (summarize)`: Виводить лише загальний підсумок для кожного вказаного аргументу, не перелічуючи всі підпапки.
- `-a (all)`: Показує розмір не тільки директорій, а й кожного окремого файлу.
- `-c (total)`: Додає в кінці рядок "total" із загальною сумою всіх перевірених об'єктів.
- `-d N` або `--max-depth=N`: Обмежує глибину рекурсії. Наприклад, -d 1 покаже лише папки в поточній директорії, не заглиблюючись далі.

## 3. Технічні та специфічні аргументи
- `-b (bytes)`: Еквівалентно `--apparent-size --block-size=1`. Виводить точний розмір у байтах.
- `-k`: Виводити розмір у кілобайтах (1024 байт).
- `-m`: Виводити розмір у мегабайтах.

  Примітка. Аргументи -k та -m (мають довгі варіанти)
  
   Для них існують повні назви, хоча їх рідко використовують:
    - `-k` — те саме, що `--block-size=1K`.
    - `-m` — те саме, що `--block-size=1M`.
  
   Також існують варіанти `--kilobytes` та `--megabytes`, але в сучасних версіях Manual Pages їх часто називають застарілими або просто вказують через `--block-size`.
- `-L (dereference)`: Слідувати за символічними посиланнями (рахувати розмір об'єкта, на який веде посилання).
- `-x (one-file-system)`: Ігнорувати директорії на інших файлових системах (наприклад, якщо примонтовано інший диск у підпапку).
- `--apparent-size`: Показує реальний обсяг даних у файлі, а не те, скільки він займає на диску (це важливо для "дірявих" файлів).
- `--exclude="ШАБЛОН"`: Дозволяє виключити файли або папки за маскою (наприклад, --exclude="*.log").
- `-X FILE (--exclude-from=FILE)`: це "професійний" спосіб фільтрації виводу du. Замість того, щоб прописувати кожен шаблон вручну в терміналі, ви передаєте команді текстовий файл зі списком усього, що треба ігнорувати.
  <details>
    <summary>Ось як це працює:</summary>
    1. Як створити файл виключень
    
    Створіть звичайний текстовий файл (наприклад, ignore.txt) і впишіть у нього шаблони — кожен з нового рядка:
    ```
    text
    *.log
    tmp/
    node_modules
    .cache
    backup*.tar.gz
    ```
      
    2. Запуск команди
    
    Тепер вкажіть цей файл при запуску du:
    ```bash
    du -h --exclude-from=ignore.txt /path/to/dir
    ```
    
    Або використовуючи коротку версію:
    ```bash
    du -h -X ignore.txt /path/to/dir
    ```
     
    3. Важливі правила написання шаблонів
    
    - Відносні шляхи: Команда порівнює шаблони з назвами файлів і папок відносно точки входу. Якщо ви вкажете tmp, будуть ігноруватися всі папки tmp на будь-якому рівні вкладеності.

    - Спецсимволи (Wildcards):
      - `*` — будь-яка кількість символів (наприклад, *.mp4).
      - `?` — рівно один будь-який символ.
      - `[...]` — діапазон символів (наприклад, [0-9]* ігнорує все, що починається з цифри).
    - Порожні рядки та коментарі: Порожні рядки у файлі ігноруються, але будьте обережні — пробіли в кінці рядка можуть вважатися частиною імені файлу.
    
    Коли це корисно?
    - Чистий бекап: Коли ви хочете знати реальну вагу папок, які підуть в архів, без сміттєвих файлів (.DS_Store, thumbs.db, кеш).
    - Робота з проектами: Вказати файл .gitignore як джерело для виключень:
      ```bash
      du -h --exclude-from=.gitignore
      ```
      (Правда, синтаксис .gitignore трохи складніший за стандартні шаблони du, тому спрацює лише для простих правил).
    - Постійна робота: Якщо ви часто перевіряєте сервер, можна тримати стандартний "black list" файлів, які завжди займають місце, але вас не цікавлять.
    
      До речі, згідно з GNU Coreutils Manual, якщо вказати - замість імені файлу (`-X -`), du зчитає список шаблонів прямо зі стандартного вводу.
  </details>
- `--threshold` (або скорочено `-t`): це потужний фільтр, який дозволяє ігнорувати занадто малі або занадто великі об'єкти у виводі du. 
   <details>
     <summary>Ось як він працює:</summary>
     
    **1. Фільтрація за мінімальним розміром (позитивне значення)**

    Якщо ви вкажете позитивне число, du покаже лише ті директорії/файли, розмір яких більший або дорівнює заданому значенню. 

    Приклад: Показати тільки об'єкти, що займають більше 1 ГБ:

   ```bash
      du -h --threshold=1G
   ```
   
    **2. Фільтрація за максимальним розміром (від'ємне значення)**

   Якщо додати знак «мінус» перед числом, команда виведе лише ті об'єкти, розмір яких менший або дорівнює вказаному. 

   Приклад: Знайти дрібні папки/файли (менше 10 МБ):
    ```bash
    du -h --threshold=-10M
    ```
    
    **3. Формат розміру (SIZE)**
       
    Для аргументу можна використовувати стандартні одиниці виміру:
  
    - K, M, G, T — ступені 1024 (KiB, MiB, GiB).
    - KB, MB, GB — ступені 1000 (Kilobytes, Megabytes).
    
    **Важливі нюанси:**
    - Сумісність: Цей параметр доступний у версіях GNU Coreutils (Linux), але його може не бути в macOS (BSD версія) або старих дистрибутивах (наприклад, RHEL 6).
    - Загальна сума: Навіть якщо об'єкт відфільтрований і не відображається у списку, його розмір все одно буде врахований у підсумковому значенні, якщо ви використовуєте прапорець `-c` (total).
    - Альтернатива: Якщо ваша версія du не підтримує `--threshold`, аналогічного результату можна досягти через `find`:
      ```bash
      find . -size +1G -exec du -h {} +
      ```
</details>

- `--time`: Показує час останньої модифікації кожного об'єкта.
  Сама команда --time зазвичай не має короткої літери, але вона має розширені варіації:
  -  --time — виводить час останньої модифікації.
  -  `--time-style=STYLE` — дозволяє налаштувати формат дати
  <details>
    <summary>Налаштування формату дати</summary>
    
    Аргумент --time-style дозволяє гнучко налаштувати відображення часу. Ви можете вибрати як стандартні стилі, так і задати власний формат за допомогою специфікаторів date.
    Згідно з документацією GNU Coreutils, доступні такі варіанти:
    
    1. Стандартні стилі
    - `full-iso`: Максимально детальний формат (ISO 8601) з наносекундами та часовим поясом.
   
       Вигляд: `2024-05-20 14:30:05.123456789 +0300`
    - `long-iso`: Чіткий та зручний формат без наносекунд.
   
       Вигляд: `2024-05-20 14:30`
    - `iso`: Спрощений формат. Якщо файл змінено давно, покаже лише дату; якщо нещодавно — дату та час.
    
       Вигляд: `2024-05-20` або `05-20 14:30`
    
    - `locale`: Використовує формат, прийнятий у вашій системі (залежить від змінної $LANG).
    
    2. Користувацький формат (Custom)
    Ви можете задати власний рядок форматування, використовуючи ті ж символи, що й у команді date. Формат записується так: +ФОРМАТ.
    
    Найпопулярніші символи:
    - `%Y` — рік (2024)
    - `%m` — місяць (01-12)
    - `%d` — день місяця (01-31)
    - `%H` — години (00-23)
    - `%M` — хвилини (00-59)
    - `%S` — секунди
    
    Приклад команди:
    ```bash
    du -h --time --time-style="+%d-%m-%Y %H:%M" /var/log
    ```
    Результат виведе дату у форматі: `20-05-2024 14:30`.

    3. Використання змінної оточення
    
    Якщо ви хочете, щоб du завжди показував час у певному стилі, ви можете встановити змінну TIME_STYLE у вашому файлі .bashrc:
    ```bash
    export TIME_STYLE="long-iso"
    ```
    Нюанс: Якщо вказати два формати через перехід на новий рядок (наприклад, для "недавніх" та "старих" файлів), du буде перемикатися між ними автоматично, як це робить команда ls.
  </details>

Зведена таблиця
| Короткий	| Повний |	Опис |
| --------- | ------ | ------|
| -a | --all | Показує розмір не тільки директорій, а й кожного окремого файлу |
| немає	| --apparent-size |	Вимірює "видимий" обсяг даних|
| -b	| --bytes або --apparent-size --block-size=1	| Розмір у байтах |
| -c | --total | Додає в кінці рядок "total" із загальною сумою всіх перевірених об'єктів |
| -d N | --max-depth=N | Обмежує глибину рекурсії |
| -h |--human-readable | Виводить розмір у зручному форматі (K, M, G).  |
| -s | --summarize | Виводить лише загальний підсумок для кожного вказаного аргументу, не перелічуючи всі підпапки |
| немає	| --time |	Показує час зміни |
| немає	| --exclude	| Ігнорує файли за шаблоном |
| -k	| --block-size=1K	| Розмір у Кілобайтах |
| -m	| --block-size=1M	| Розмір у Мегабайтах |
| -L  | --dereference | Слідувати за символічними посиланнями  |
| -x | --one-file-system | Ігнорувати директорії на інших файлових системах  |
| -t | --threshold | фільтрує об'єкти за розміром у виводі du |
| немає |  --exclude="ШАБЛОН"| Дозволяє виключити файли або папки за маскою |
| -X FILE | --exclude-from=FILE |  Замість того, щоб прописувати кожен шаблон вручну в терміналі, ви передаєте команді текстовий файл зі списком усього, що треба ігнорувати |



## 4. Приклади використання

Подивитися розмір папок у поточному каталозі (читабельно):
```bash
du -sh *
```
Дізнатися розмір конкретної папки та всіх її підпапок першого рівня:
```bash
du -h --max-depth=1 /var/log
```
Знайти 10 найбільших папок/файлів:
```bash
du -ah | sort -rh | head -n 10
```
(Тут ми використовуємо Sort для сортування результатів).

Подивитися сумарну вагу декількох директорій:
```bash
du -sch /home/user/Downloads /home/user/Documents
```

## 5. Різниця між du та df
`du` сканує файлову систему і рахує розмір кожного об'єкта індивідуально.

`df` (disk free) запитує інформацію безпосередньо у файлової системи про стан всього диска. df працює миттєво, тоді як du на великих обсягах даних може вимагати часу.

Більш детальну технічну документацію можна знайти в офіційному [GNU Coreutils Manual](https://www.gnu.org/software/coreutils/manual/coreutils.html).


