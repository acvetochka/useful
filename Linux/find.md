# Команда find 

Команда find — це один із найпотужніших інструментів у Linux. Її синтаксис виглядає так:
  ```bash
  find [шлях] [вирази/критерії] [дії]
  ```

Ось докладна довідка за основними можливостями GNU Findutils.
## 1. Пошук за метаданими (Критерії)
| Ключ	| Опис | 	Приклад |
| ---- | -----| ------|
| -name	| Пошук за ім'ям (чутливий до регістру)	| find . -name "test.txt"|
| -iname |	Пошук за ім'ям (нечутливий до регістру)	| find . -iname "*.Jpg"|
| -type | 	Тип об'єкта (f-файл, d-папка, l-посилання)	| find /etc -type d|
| -size |	Розмір (k, M, G). + більше, - менше	| find . -size +100M |
| -user | -group	| Власник або група файлу	| find /home -user john |
| -perm	| Права доступу (числові або символьні) |	find . -perm 777 |
| -empty	| Тільки порожні файли або директорії	| find . -type f -empty |

## 2. Пошук за часом
Тут використовуються префікси: `+` (більше ніж), `-` (менше ніж) або без знака (рівно).
- `-mtime n`: Зміна вмісту файлу (у днях).
- `-atime n`: Останній доступ до файлу (читання).
- `-ctime n`: Зміна метаданих (права, власник) або вмісту.
- `-mmin n`,`-amin n`: Аналогічно, але у хвилинах.

Приклад: 
```bash
find /var/log -mtime -2
# (файли, змінені за останні 2 дні).
```

## 3. Логічні оператори (Об'єднання умов)
- `-a` (або `-and`): Логічне "І". Використовується за замовчуванням.
- `-o` (або `-or`): Логічне "АБО".
- `!` (або `-not`): Заперечення умови.
- `\( \)` : Групування умов для пріоритету.

Приклад: 
```bash
find . -type f -not -name "*.git*"
# (всі файли, крім тих, що містять .git).
```

## 4. Дії над знайденими файлами
За замовчуванням find просто виводить список (-print). Але можна додати інші дії:
- `-delete`: Видалити знайдені об'єкти (будьте обережні!).
- `-ls`: Показати детальну інформацію (як ls -dils).
- `-exec [команда] {} \;` : Виконати команду для кожного файлу. {} — це місце, куди підставляється ім'я файлу.

Приклад:
```bash
find . -name "*.tmp" -exec rm -f {} \;
#(знайти та видалити всі .tmp файли).
```
<details>
  <summary>Докладніше про exec</summary>
      Синтаксис -exec спочатку здається дивним, але він дуже логічний. Розберемо це «на пальцях».
 
  **  1. Що таке {}?**
  
  Це заповнювач (placeholder). Уявіть, що find знайшов три файли: 1.tmp, 2.tmp і 3.tmp.
  
  Коли ви пишете `-exec rm {} \;`, команда find по черзі підставляє ім'я кожного файлу замість цих дужок і запускає команду:
    ```bash
    rm 1.tmp
    rm 2.tmp
    rm 3.tmp
    ```
  Це і означає «місце, куди підставляється ім'я». Ви можете поставити {} будь-куди в команді, наприклад:
    ```bash
    find . -name "*.txt" -exec cp {} /backup/ \;
    ```
  (Тут кожен знайдений файл буде скопійовано в папку /backup/).
  
  **2. Що таке \; в кінці?**
  Це «крапка» в кінці речення для find. Вона каже йому: «Ось тут команда, яку треба виконати, закінчується».
  Зворотний слеш \ потрібен, щоб Shell (ваша оболонка) не сприйняв крапку з комою ; як свій власний символ, а передав її саме команді find.
  3. Чи це те саме, що конвеєр | (pipe)?
  Ні, це працює інакше.
  Конвеєр | передає текст (стандартний вивід). Якщо ви напишете find ... | rm, це не спрацює, бо rm не вміє читати назви файлів з тексту, він чекає їх як аргументи.
  -exec не передає текст. Він генерує і запускає нову команду для кожного знайденого файлу.
  Порівняння:
  Метод	Як працює	Приклад
  -exec ... {} ;	Запускає команду окремо для кожного файлу.	find -name "*.log" -exec rm {} \;
  xargs	Збирає всі назви в один довгий список і запускає команду один раз.	`find -name "*.log"
  Варіант з + (бонус)
  Якщо замість \; в кінці поставити +, то find поведеться як xargs: він підставить усі знайдені файли в одну команду за один раз:
  rm 1.tmp 2.tmp 3.tmp ...
  Це працює швидше, якщо файлів тисячі.
  
  Вибір між \; та + — це питання балансу між швидкістю (продуктивністю) та гнучкістю.
  1. Використовуйте + (Масове виконання) — для швидкості
  Це аналог передачі всього масиву аргументів в одну функцію. find збирає всі імена файлів і запускає команду один раз (або мінімальну кількість разів, якщо імен дуже багато).
  Коли обирати: Коли потрібно обробити тисячі файлів і команда підтримує список аргументів (наприклад, rm, ls, cp, chown, chmod).
  Плюс: Працює значно швидше, бо операційній системі не потрібно тисячу разів створювати новий процес.
  Обмеження: {} можна поставити тільки в самому кінці перед +.
  Приклад: find . -type f -name "*.log" -exec rm {} + (видалить усе за один запуск).
  2. Використовуйте \; (Поштучне виконання) — для складної логіки
  Це чистий .forEach(). Для кожного файлу створюється свій окремий процес.
  Коли обирати:
  Коли команда вміє працювати тільки з одним файлом за раз (наприклад, ffmpeg для конвертації відео).
  Коли вам потрібно використати {} кілька разів у команді (наприклад, копіювання файлу: cp {} {}.bak).
  Коли важливий результат виконання для кожного окремого файлу.
  Мінус: Повільно на великій кількості файлів.
  Приклад: find . -name "*.jpg" -exec mv {} {}.old \; (тут + не спрацює, бо mv не зрозуміє, що куди перейменовувати в масовому списку).
  Підсумкова таблиця
  Характеристика	-exec ... {} \;	-exec ... {} +
  Аналогія JS	.forEach(file => cmd(file))	cmd(...files)
  Швидкість	Повільно (1 файл = 1 процес)	Швидко (всі файли = 1 процес)
  Гнучкість	Висока (будь-яке місце для {})	Низька (тільки в кінці)
  Коли брати	Перейменування, конвертація	Видалення, пошук тексту, зміна прав
  Маленький нюанс: Якщо ви використовуєте +, але файлів так багато, що їхні назви не влазять в обмеження командного рядка Linux (зазвичай це ~2 МБ тексту), find сам розіб'є їх на кілька запусків. Тобто він "розумніший" за звичайний xargs.
</details>

## 5. Обмеження глибини
- `-maxdepth N`: Шукати не глибше ніж N рівнів.
- `-mindepth N`: Починати пошук тільки з N-го рівня.

## Практичні приклади для копіювання:
- Знайти великі файли та вивести їх розмір:
  ```bash
  find /home -type f -size +500M -exec ls -lh {} +
  ```
- Змінити права тільки для папок:
  ```bash
  find /var/www -type d -exec chmod 755 {} +
  ```
- Знайти файли, змінені за останні 10 хвилин:
  ```bash
  find . -type f -mmin -10
  ```
- Пошук файлів з кількома розширеннями:
  ```bash
  find . -type f \( -name "*.sh" -o -name "*.py" \)
  ```
