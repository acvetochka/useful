# Команда history

## Коротка довідка про команду history у Bash:

**Призначення**

Команда history відображає список команд, які ви вводили раніше, і дозволяє ними керувати.

**Основні параметри**

- `history` — показати весь список з номерами.
- `history N` — показати лише останні N команд (наприклад, history 5).
- `history -c` — повністю очистити історію в поточній сесії (Clear).
- `history -d offset` — видалити конкретний рядок за його номером (Delete).
- `history -w` — негайно записати поточну історію з пам'яті у файл ~/.bash_history (Write).

**Гарячі клавіші та символи (Швидкий доступ)**
- `!!` — повторити останню команду.
- `!N` — повторити команду під номером N.
- `!-N` — повторити команду, яка була N кроків тому.
- `Ctrl + R` — інтерактивний пошук по історії (почніть вводити слово, щоб знайти команду).

**Ключові змінні (в ~/.bashrc)**
- `HISTSIZE` — ліміт команд у пам'яті.
- `HISTFILESIZE` — ліміт команд у файлі на диску.
- `HISTCONTROL` — правила ігнорування (пробіли, дублікати).
- `HISTTIMEFORMAT` — налаштування відображення дати й часу.

## history -d offset
Команда history -d offset у Bash використовується для видалення конкретних записів з історії команд поточної сесії. 

**Основне призначення**
- Дія: Видаляє рядок під номером offset зі списку історії в пам'яті.
- Що таке offset: Це порядковий номер команди, який ви бачите ліворуч, коли вводите просто history. 

**Приклади використання**
1. Видалення одного запису:
   
    Щоб видалити команду під номером 500:
    ```bash
    history -d 500
    ```

2. Видалення діапазону (Bash 5.0+):
   
    Видалити команди з 500 по 510 включно:
    ```bash
    history -d 500-510
    ```

3. Видалення з кінця:

    Використання від'ємного числа дозволяє рахувати з кінця списку. Наприклад, видалити передостанню команду:
    ```bash
    history -d -1
    ```

 
**Важливі нюанси**
- Зміни в пам'яті: Команда видаляє запис лише з поточної оперативної пам'яті оболонки.
- Синхронізація з файлом: Щоб видалений рядок зник і з файлу історії на диску (~/.bash_history), потрібно перезаписати файл командою:
  ```bash
  history -w
  ```

- Нумерація: Після видалення запису номери наступних команд в історії зміщуються, тому будьте уважні при послідовному видаленні кількох рядків вручну. 

Коли ви вводите history -d -1, ви видаляєте передостанній запис. Останнім записом у списку завжди є сама команда видалення, яку ви щойно ввели.

Ось як це працює в Bash:
- Ви вводите: history -d -1
- Bash додає цю команду в історію як останню.
- Параметр -1 вказує на запис, що стоїть перед нею (тобто ту команду, яку ви насправді хотіли стерти).
- В результаті: "погана" команда зникає, а сама history -d -1 залишається в списку.

**Як видалити "погану" команду і не залишити слідів?**

Якщо ваша мета — видалити попередню команду так, щоб в історії не залишилося навіть самої команди видалення, краще зробити так:
  ```bash
  history -d $(history 1 | awk '{print $1}')
  ```

Або простіший спосіб очистити останній запис після виконання:
  ```bash
  history -d $((HISTCMD-1))
  ```

**Чому -1 видаляє саме передостанню?**
- 0 (або просто останній індекс) — це команда, яку ви виконуєте зараз.
- -1 — це одна команда назад від поточної.

**Порада:** Якщо ви хочете, щоб певні команди взагалі не потрапляли в історію, просто поставте пробіл перед командою (наприклад, ls -la). Це працює, якщо у вас налаштована змінна HISTCONTROL=ignorespace або ignoreboth (що є стандартом у багатьох дистрибутивах).

## HISTCONTROL
Перевірити значення змінної `HISTCONTROL` можна за допомогою команди echo або printenv безпосередньо в терміналі.

**Як перевірити в поточній сесії:**

Введіть у терміналі:
  ```bash
  echo $HISTCONTROL
  ```

Якщо ви побачите у відповіді `ignorespace` або `ignoreboth`, значить функція ігнорування команд із пробілом у вас увімкнена. 
Якщо порожньо — функція вимкнена. 

**Порівняння значень:**
| Значення |	Що робить |
| -------- | ---------- |
| ignoredups |	Не записує команду, якщо вона ідентична попередній. |
| ignorespace	| Не записує команди, що починаються з пробілу. |
| ignoreboth |	Поєднує обидва правила (дублікати + пробіли). |
| erasedups	| (Найрадикальніший) Видаляє всі попередні згадки такої ж команди з усієї історії, залишаючи лише останню. |

Важливо: `ignoredups` перевіряє тільки попередній рядок. Якщо ви введете ls, потім cd, а потім знову ls — у вас в історії буде два ls. Якщо ж ви хочете бачити лише один ls у всій історії, використовуйте `erasedups`.

Щоб об’єднати кілька правил, їх потрібно перелічити через двокрапку.

Найпотужніша комбінація, яку використовує більшість досвідчених користувачів:
```bash
export HISTCONTROL=ignoreboth:erasedups
```

Що це дає в результаті:
- ignorespace (входить у ignoreboth): Команди з пробілом попереду не зберігаються.
- ignoredups (входить у ignoreboth): Якщо ви введете ту саму команду двічі поспіль, вона не дублюватиметься.
erasedups: Якщо ви введете команду, яка вже була в історії десь раніше (навіть 100 кроків тому), стара згадка видалиться, а нова з'явиться в самому кінці. Історія стає ідеально чистою та унікальною.

**Як перевірити конфігураційний файл (постійні налаштування):**

Змінна зазвичай прописується у файлі `~/.bashrc`. Ви можете швидко знайти її через grep:
  ```bash
  grep "HISTCONTROL" ~/.bashrc
  ```

**Як увімкнути, якщо не налаштовано:**

Якщо ви хочете активувати цю функцію, додайте рядок у свій ~/.bashrc:
- Відкрийте файл: `nano ~/.bashrc`
- Додайте в кінець: `export HISTCONTROL=ignoreboth`
- Оновіть налаштування: `source ~/.bashrc `

**Порада:** Ви можете перевірити роботу миттєво: введіть команду з пробілом (наприклад, ls), а потім введіть history. Якщо налаштування активне, ls у списку не з'явиться. 

## HISTSIZE
**Цікавий факт:** Якщо ви додасте до цього ще й `HISTSIZE=10000`, ваша історія перетвориться на зручну базу знань, де немає сміття, але завжди можна знайти унікальну команду, яку ви вводили місяць тому.

За замовчуванням у більшості сучасних дистрибутивів (як-от Ubuntu чи Debian) встановлено ліміт у `1000` або `2000` команд. 

Однак, якщо Bash не знаходить жодних налаштувань, його "вбудований" ліміт зазвичай становить лише `500` записів.

**У чому різниця між HISTSIZE та HISTFILESIZE?**

Для правильного налаштування важливо знати обидві змінні:
- `HISTSIZE`: скільки команд зберігається в оперативній пам'яті поточної сесії. 
- `HISTFILESIZE`: скільки команд може зберігатися у файлі на диску (~/.bash_history). 

Якщо ви встановите `HISTSIZE=10000`, обов'язково встановіть такий же або більший ліміт для `HISTFILESIZE`, інакше старі команди будуть видалятися з файлу при закритті термінала.

**Як перевірити свій поточний ліміт:**

Введіть у терміналі:
```bash
echo $HISTSIZE
```

**Порада: ** Багато адміністраторів ставлять дуже великі значення (наприклад, 50000), оскільки текстові файли історії займають мінімум місця, але зберігають місяці вашої роботи. [3]

## HISTTIMEFORMAT
Додавання дати й часу робить історію значно кориснішою, бо ви зможете згадати, коли саме вносили зміни в конфігурацію або виконували важливий скрипт.

За це відповідає змінна `HISTTIMEFORMAT`.

**Як це налаштувати**

Вам потрібно визначити формат часу за допомогою стандартних символів strftime. Найпопулярніший варіант:
```bash
export HISTTIMEFORMAT="%F %T "
```

- `%F` — повна дата (РРРР-ММ-ДД).
- `%T` — час (ГГ:ХХ:СС).

**Важливо:** Пробіл в кінці лапок потрібен, щоб дата не зливалася з текстом команди.

**Як це виглядає в терміналі**

Після налаштування команда history видаватиме щось подібне:
  ```text
    500  2024-05-20 14:30:05 ls -la
    501  2024-05-20 14:31:12 nano ~/.bashrc
    502  2024-05-20 14:35:50 history
  ```

**Як зробити налаштування постійними**

Додайте цей рядок у свій файл `~/.bashrc`, щоб він працював у кожному новому терміналі:
- Відкрийте файл: `nano ~/.bashrc`
- Додайте в кінець:
    ```bash
    export HISTTIMEFORMAT="%d.%m.%y %H:%M:%S "
    ```
    
    (Цей формат виглядає як ДД.ММ.РР ГГ:ХХ:СС, що звичніше для нашого регіону).
- Застосуйте зміни: `source ~/.bashrc`

**Нюанс щодо минулих команд**
Bash починає записувати час лише після того, як ви встановили цю змінну. Для всіх команд, які були введені до цього, Bash не знає точного часу, тому він просто підставить поточний час (момент активації змінної). Наступні ж команди матимуть коректні мітки.

