# Оператори

У Linux символи та оператори дозволяють керувати потоками даних, логікою виконання команд та процесами. Ось детальне пояснення основних категорій:
## 1. Оператори перенаправлення (Redirection)

Ці символи змінюють стандартні шляхи введення та виведення. 
- `>` (Виведення): Записує стандартний вивід (stdout) у файл, перезаписуючи його вміст. Наприклад: ls > files.txt.
- `>>` (Додавання): Додає вивід у кінець існуючого файлу, не видаляючи старі дані.
- `<` (Введення): Бере дані з файлу замість клавіатури. Наприклад: mysql database < backup.sql.
- `2>` (Помилки): Перенаправляє лише повідомлення про помилки (stderr) у файл.
- `&>` або `2>&1`: Спрямовує і звичайний результат, і помилки в одне місце.
  <details>
    <summary>Докладніше про різницю між `&>` та `2>&1` </summary>
  
    Вони роблять одну і ту саму роботу — об'єднують обидва потоки (стандартний вивід stdout та помилки stderr) в один канал. Але між ними є суттєва різниця в сумісності та синтаксисі.
    
    1. `2>&1` (Класичний спосіб)
        - Це стандартний метод, який працює в усіх POSIX-сумісних оболонках (sh, dash, bash, zsh).
        - Як читати: "Спрямуй потік 2 (stderr) туди ж, куди зараз спрямовано потік 1 (stdout)".
        - Важливий порядок: Ви спочатку повинні сказати, куди йде потік 1, а потім "підтягнути" до нього потік 2.
        - Приклад: `command > file.log 2>&1`
  
        (Якщо написати 2>&1 > file.log, то помилки підуть на екран, а результат у файл, бо на момент об'єднання потік 1 ще дивився на екран).
    
    2. &> (Скорочення Bash)
        - це специфічний синтаксис (так званий "bashism"), який з'явився в Bash (також працює в Zsh).
        - Як читати: "Спрямуй абсолютно все в цей файл".
        - Перевага: Коротше записувати, не треба думати про порядок потоків.
        - Приклад: command &> file.log
        - Мінус: Ця команда не спрацює у стандартному системному шелі /bin/sh (наприклад, у скриптах автоматизації Debian/Ubuntu, де /bin/sh — це dash).
    
    Порівняльна таблиця
    | Особливість	| command > file 2>&1	| command &> file |
    | ------------| ------------------- | ----------------|
    | Сумісність	| Працює всюди (sh, bash, zsh, dash)	| Тільки Bash та Zsh|
    | Читабельність |	Більш технічна, "стара школа"	| Сучасна, коротка|
    | Стійкість	| Потрібно дотримуватись порядку	| Порядок не має значення |

    Що краще використовувати?
  
    - Якщо ви пишете команду просто в терміналі і у вас Bash — використовуйте &>, це швидше.
    - Якщо ви пишете скрипт (.sh), який має працювати на різних серверах — завжди використовуйте > file 2>&1. Це гарантує, що скрипт не "впаде" через несумісність оболонок.

  </details>
  
## 2. Оператор конвеєра (Piping)
- `|` (Pipe): Передає вивід однієї команди як вхідні дані для іншої. Це дозволяє створювати ланцюжки обробки.

   Приклад: `cat log.txt | grep "Error"` (команда grep шукатиме слово "Error" у тексті, який видасть cat).

## 3. Логічні оператори та розділювачі
Використовуються для керування послідовністю команд залежно від їхнього успіху. 

- `&&` (AND): Наступна команда виконається лише якщо перша була успішною (код виходу 0).

   Приклад: `make && sudo make install` (інсталяція почнеться тільки після вдалої компіляції).

- `||` (OR): Наступна команда виконається лише якщо перша завершилася помилкою.

   Приклад: `mkdir test || echo "Failed to create directory"`.
- `;` (Скрапка з комою): Просто розділяє команди. Вони виконуються по черзі, незалежно від результату попередньої. 

## 4. Керування процесами
- `&` (Амперсанд): Запускає команду у фоновому режимі. Термінал залишається вільним для інших команд, поки процес працює «за лаштунками». 

## 5. Інші важливі символи
- `*` та `?` (Wildcards): Маски для пошуку файлів.
  - `*` — будь-яка кількість символів,
  - `?` — один будь-який символ.
- `$`: Ознака змінної (наприклад, $HOME) або підстановка результату команди $(command).
- `#`: Початок коментаря в скриптах.
- `\` (Escape): Скасовує спеціальне значення символу, що йде наступним (наприклад, дозволяє використовувати пробіл або лапки в імені файлу). 


